<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Function Limit Calculator with Graph</title>
    <!-- Fallback for Math.js - included inline if CDN fails -->
    <script>
        // Try to load Math.js from CDN, fall back to local calculation functions
        (function() {
            var script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/mathjs@11.6.0/lib/browser/math.min.js';
            script.onerror = function() {
                console.log('Math.js CDN failed, using fallback calculations');
                window.mathjsFailed = true;
            };
            document.head.appendChild(script);
        })();
    </script>
    <!-- Fallback for Plotly -->
    <script>
        (function() {
            var script = document.createElement('script');
            script.src = 'https://cdn.plot.ly/plotly-2.24.1.min.js';
            script.onerror = function() {
                console.log('Plotly CDN failed, using simple canvas fallback');
                window.plotlyFailed = true;
            };
            document.head.appendChild(script);
        })();
    </script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a237e 0%, #4a148c 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(90deg, #303f9f 0%, #512da8 100%);
            color: white;
            padding: 25px;
            text-align: center;
        }
        
        h1 {
            font-size: 2rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1rem;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .content {
            display: flex;
            flex-wrap: wrap;
            padding: 20px;
        }
        
        .input-section {
            flex: 1;
            min-width: 300px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 10px;
            margin-right: 20px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }
        
        .graph-section {
            flex: 2;
            min-width: 300px;
            padding: 20px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            margin-bottom: 20px;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #303f9f;
        }
        
        input, select {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #c5cae9;
            border-radius: 6px;
            font-size: 1rem;
            transition: border-color 0.3s;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: #303f9f;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        #calculateBtn {
            background-color: #303f9f;
            color: white;
        }
        
        #calculateBtn:hover {
            background-color: #283593;
            transform: translateY(-2px);
        }
        
        #resetBtn {
            background-color: #f5f5f5;
            color: #555;
        }
        
        #resetBtn:hover {
            background-color: #e0e0e0;
            transform: translateY(-2px);
        }
        
        .result-box {
            margin-top: 20px;
            padding: 15px;
            background-color: #e8eaf6;
            border-radius: 6px;
            border-left: 5px solid #303f9f;
        }
        
        .result-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #303f9f;
        }
        
        #result {
            font-size: 1.1rem;
            font-family: 'Courier New', monospace;
            min-height: 24px;
        }
        
        #graph {
            width: 100%;
            height: 400px;
            background-color: white;
            border-radius: 6px;
            margin-top: 10px;
            border: 1px solid #ddd;
        }
        
        #graphFallback {
            width: 100%;
            height: 400px;
            border: 1px solid #ddd;
            border-radius: 6px;
            margin-top: 10px;
        }
        
        .instructions {
            margin-top: 20px;
            padding: 15px;
            background-color: #f1f8e9;
            border-radius: 8px;
            border-left: 5px solid #7cb342;
        }
        
        .instructions h3 {
            color: #558b2f;
            margin-bottom: 8px;
            font-size: 1.1rem;
        }
        
        .instructions ul {
            padding-left: 20px;
            font-size: 0.9rem;
        }
        
        .instructions li {
            margin-bottom: 6px;
        }
        
        .example-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 8px;
            margin-top: 12px;
        }
        
        .example-item {
            padding: 8px;
            background-color: white;
            border-radius: 5px;
            border: 1px solid #c5cae9;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85rem;
        }
        
        .example-item:hover {
            background-color: #e8eaf6;
        }
        
        .function-example {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #303f9f;
            margin-bottom: 4px;
        }
        
        footer {
            text-align: center;
            padding: 15px;
            color: #9e9e9e;
            font-size: 0.8rem;
            border-top: 1px solid #eee;
        }
        
        .error-message {
            color: #d32f2f;
            background-color: #ffebee;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            display: none;
        }
        
        @media (max-width: 768px) {
            .content {
                flex-direction: column;
            }
            
            .input-section {
                margin-right: 0;
            }
            
            h1 {
                font-size: 1.5rem;
            }
            
            #graph {
                height: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Function Limit Calculator</h1>
            <p class="subtitle">Enter a mathematical function, specify the limit point, and visualize the function graph</p>
        </header>
        
        <div class="error-message" id="errorDisplay">
            <strong>Note:</strong> Some external resources may not have loaded. The calculator is using fallback methods.
        </div>
        
        <div class="content">
            <div class="input-section">
                <div class="input-group">
                    <label for="functionInput">Function f(x)</label>
                    <input type="text" id="functionInput" value="sin(x)/x" placeholder="e.g., sin(x)/x, x^2+2*x+1">
                    <small>Use: sin(x), cos(x), tan(x), log(x), sqrt(x), ^ for power, * for multiplication</small>
                </div>
                
                <div class="input-group">
                    <label for="limitPoint">Limit Point (x → a)</label>
                    <input type="text" id="limitPoint" value="0" placeholder="Enter a number or 'inf' for infinity">
                </div>
                
                <div class="input-group">
                    <label for="direction">Direction</label>
                    <select id="direction">
                        <option value="both">Both sides (x → a)</option>
                        <option value="left">Left side only (x → a⁻)</option>
                        <option value="right">Right side only (x → a⁺)</option>
                    </select>
                </div>
                
                <div class="input-group">
                    <label>Try these examples:</label>
                    <div class="example-list">
                        <div class="example-item" data-func="sin(x)/x" data-point="0">
                            <div class="function-example">sin(x)/x</div>
                            <div>as x → 0</div>
                        </div>
                        <div class="example-item" data-func="(x^2-1)/(x-1)" data-point="1">
                            <div class="function-example">(x²-1)/(x-1)</div>
                            <div>as x → 1</div>
                        </div>
                        <div class="example-item" data-func="1/x" data-point="0">
                            <div class="function-example">1/x</div>
                            <div>as x → 0</div>
                        </div>
                        <div class="example-item" data-func="x*sin(1/x)" data-point="0">
                            <div class="function-example">x*sin(1/x)</div>
                            <div>as x → 0</div>
                        </div>
                    </div>
                </div>
                
                <div class="button-group">
                    <button id="calculateBtn">Calculate Limit</button>
                    <button id="resetBtn">Reset</button>
                </div>
                
                <div class="result-box">
                    <div class="result-title">Limit Result:</div>
                    <div id="result">Click "Calculate Limit" to see result</div>
                </div>
            </div>
            
            <div class="graph-section">
                <h2>Graphical Representation</h2>
                <div id="graph">Loading graph...</div>
                <canvas id="graphFallback" style="display: none;"></canvas>
            </div>
        </div>
        
        <div class="instructions">
            <h3>How to Use This Calculator</h3>
            <ul>
                <li>Enter a mathematical function using standard notation</li>
                <li>Specify the limit point (number or "inf" for infinity)</li>
                <li>Select the direction of approach</li>
                <li>Click "Calculate Limit" to compute and visualize</li>
                <li>Click on any example to try it</li>
            </ul>
        </div>
        
        <footer>
            <p>Function Limit Calculator | Works offline with fallback methods</p>
        </footer>
    </div>

    <script>
        // Wait for DOM to be ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing calculator...');
            
            // DOM Elements
            const functionInput = document.getElementById('functionInput');
            const limitPoint = document.getElementById('limitPoint');
            const direction = document.getElementById('direction');
            const calculateBtn = document.getElementById('calculateBtn');
            const resetBtn = document.getElementById('resetBtn');
            const result = document.getElementById('result');
            const graph = document.getElementById('graph');
            const graphFallback = document.getElementById('graphFallback');
            const errorDisplay = document.getElementById('errorDisplay');
            const exampleItems = document.querySelectorAll('.example-item');
            
            // Check if external libraries loaded
            let mathAvailable = typeof math !== 'undefined';
            let plotlyAvailable = typeof Plotly !== 'undefined';
            
            // Show error if libraries didn't load
            if (!mathAvailable || !plotlyAvailable) {
                errorDisplay.style.display = 'block';
                console.log('Using fallback mode. Math.js available:', mathAvailable, 'Plotly available:', plotlyAvailable);
            }
            
            // Fallback math functions if Math.js not available
            const fallbackMath = {
                sin: Math.sin,
                cos: Math.cos,
                tan: Math.tan,
                log: Math.log,
                sqrt: Math.sqrt,
                exp: Math.exp,
                abs: Math.abs,
                pow: Math.pow
            };
            
            // Simple function parser for fallback
            function parseFunction(funcStr) {
                // Replace common math notation
                funcStr = funcStr.replace(/\^/g, '**');
                
                return function(x) {
                    try {
                        // Create a safe evaluation context
                        const safeEval = new Function('x', `
                            with(Math) {
                                return ${funcStr};
                            }
                        `);
                        return safeEval(x);
                    } catch (e) {
                        // Try alternative approach
                        try {
                            // Replace x with value and evaluate
                            let expr = funcStr
                                .replace(/x/g, '(' + x + ')')
                                .replace(/\^/g, '**');
                            
                            // Handle special functions
                            expr = expr
                                .replace(/sin\(/g, 'Math.sin(')
                                .replace(/cos\(/g, 'Math.cos(')
                                .replace(/tan\(/g, 'Math.tan(')
                                .replace(/log\(/g, 'Math.log(')
                                .replace(/sqrt\(/g, 'Math.sqrt(')
                                .replace(/exp\(/g, 'Math.exp(')
                                .replace(/abs\(/g, 'Math.abs(');
                            
                            return eval(expr);
                        } catch (e2) {
                            throw new Error('Cannot evaluate function at x = ' + x);
                        }
                    }
                };
            }
            
            // Initialize with empty graph or fallback canvas
            function initializeGraph() {
                if (plotlyAvailable) {
                    try {
                        Plotly.newPlot(graph, [{
                            x: [],
                            y: [],
                            type: 'scatter',
                            mode: 'lines',
                            line: {color: '#303f9f', width: 2},
                            name: 'f(x)'
                        }], {
                            title: 'Function Graph',
                            xaxis: {title: 'x'},
                            yaxis: {title: 'f(x)'},
                            plot_bgcolor: '#f8f9fa',
                            paper_bgcolor: '#ffffff'
                        });
                        graphFallback.style.display = 'none';
                        graph.style.display = 'block';
                    } catch (e) {
                        console.error('Plotly error:', e);
                        setupCanvasFallback();
                    }
                } else {
                    setupCanvasFallback();
                }
            }
            
            // Setup canvas fallback for graphing
            function setupCanvasFallback() {
                graph.style.display = 'none';
                graphFallback.style.display = 'block';
                graphFallback.width = graphFallback.offsetWidth;
                graphFallback.height = graphFallback.offsetHeight;
                
                // Draw initial message
                const ctx = graphFallback.getContext('2d');
                ctx.clearRect(0, 0, graphFallback.width, graphFallback.height);
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, graphFallback.width, graphFallback.height);
                
                ctx.fillStyle = '#666';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Graph will appear here after calculation', 
                           graphFallback.width/2, graphFallback.height/2);
            }
            
            // Calculate limit function
            function calculateLimit() {
                const funcStr = functionInput.value.trim();
                const pointStr = limitPoint.value.trim();
                const dir = direction.value;
                
                if (!funcStr) {
                    result.innerHTML = '<span style="color:red">Please enter a function</span>';
                    return;
                }
                
                if (!pointStr) {
                    result.innerHTML = '<span style="color:red">Please enter a limit point</span>';
                    return;
                }
                
                // Show loading
                result.innerHTML = 'Calculating...';
                
                try {
                    // Parse function based on available libraries
                    let func;
                    if (mathAvailable) {
                        try {
                            func = math.compile(funcStr);
                        } catch (e) {
                            console.log('Math.js compilation failed, using fallback parser');
                            func = parseFunction(funcStr);
                        }
                    } else {
                        func = parseFunction(funcStr);
                    }
                    
                    // Parse limit point
                    let point;
                    if (pointStr.toLowerCase() === 'inf' || pointStr === '∞') {
                        point = Infinity;
                    } else if (pointStr.toLowerCase() === '-inf' || pointStr === '-∞') {
                        point = -Infinity;
                    } else {
                        point = parseFloat(pointStr);
                        if (isNaN(point)) {
                            throw new Error('Invalid limit point. Must be a number or "inf".');
                        }
                    }
                    
                    // Calculate limit numerically
                    let limitValue;
                    if (point === Infinity || point === -Infinity) {
                        limitValue = calculateLimitAtInfinity(func, point);
                    } else {
                        limitValue = calculateLimitAtPoint(func, point, dir);
                    }
                    
                    // Display result
                    displayResult(limitValue, point, dir);
                    
                    // Generate and plot graph
                    plotFunction(func, point, dir, limitValue);
                    
                } catch (error) {
                    result.innerHTML = `<span style="color:red">Error: ${error.message}</span>`;
                    console.error('Calculation error:', error);
                }
            }
            
            // Display result
            function displayResult(limitValue, point, dir) {
                let pointDisplay = point === Infinity ? '∞' : point === -Infinity ? '-∞' : point;
                let dirSymbol = '';
                if (dir === 'left') dirSymbol = '⁻';
                if (dir === 'right') dirSymbol = '⁺';
                
                if (limitValue === undefined || limitValue === null) {
                    result.innerHTML = `Limit does not exist as x → ${pointDisplay}${dirSymbol}`;
                } else if (limitValue === Infinity) {
                    result.innerHTML = `lim<sub>x→${pointDisplay}${dirSymbol}</sub> f(x) = ∞`;
                } else if (limitValue === -Infinity) {
                    result.innerHTML = `lim<sub>x→${pointDisplay}${dirSymbol}</sub> f(x) = -∞`;
                } else if (typeof limitValue === 'number') {
                    result.innerHTML = `lim<sub>x→${pointDisplay}${dirSymbol}</sub> f(x) = ${limitValue.toFixed(6)}`;
                } else {
                    result.innerHTML = `lim<sub>x→${pointDisplay}${dirSymbol}</sub> f(x) = ${limitValue}`;
                }
            }
            
            // Calculate limit at a finite point
            function calculateLimitAtPoint(func, point, dir) {
                const epsilons = [0.1, 0.01, 0.001, 0.0001];
                let leftValues = [];
                let rightValues = [];
                
                // Calculate values approaching from left and right
                for (let eps of epsilons) {
                    if (dir === 'both' || dir === 'left') {
                        try {
                            const x = point - eps;
                            const y = evaluateFunction(func, x);
                            if (isFinite(y)) leftValues.push(y);
                        } catch (e) {
                            // Ignore evaluation errors
                        }
                    }
                    
                    if (dir === 'both' || dir === 'right') {
                        try {
                            const x = point + eps;
                            const y = evaluateFunction(func, x);
                            if (isFinite(y)) rightValues.push(y);
                        } catch (e) {
                            // Ignore evaluation errors
                        }
                    }
                }
                
                // Check if limit exists
                if (dir === 'both') {
                    if (leftValues.length === 0 || rightValues.length === 0) return undefined;
                    
                    // Check if left and right limits are approximately equal
                    const leftAvg = average(leftValues);
                    const rightAvg = average(rightValues);
                    
                    if (Math.abs(leftAvg - rightAvg) > 0.01) return undefined;
                    
                    return (leftAvg + rightAvg) / 2;
                } else if (dir === 'left') {
                    if (leftValues.length === 0) return undefined;
                    return average(leftValues);
                } else { // right
                    if (rightValues.length === 0) return undefined;
                    return average(rightValues);
                }
            }
            
            // Calculate limit at infinity
            function calculateLimitAtInfinity(func, infinityDir) {
                const largeNumbers = infinityDir === Infinity ? 
                    [10, 50, 100, 500, 1000] : 
                    [-10, -50, -100, -500, -1000];
                
                const values = [];
                
                for (let x of largeNumbers) {
                    try {
                        const y = evaluateFunction(func, x);
                        if (isFinite(y)) values.push(y);
                    } catch (e) {
                        // Ignore evaluation errors
                    }
                }
                
                if (values.length === 0) return undefined;
                
                // Check if values are approaching a finite limit
                const avg = average(values);
                
                // Check for divergence
                if (values.length >= 3) {
                    const last = values[values.length - 1];
                    const secondLast = values[values.length - 2];
                    if (Math.abs(last) > Math.abs(secondLast) * 5) {
                        return last > 0 ? Infinity : -Infinity;
                    }
                }
                
                return avg;
            }
            
            // Evaluate function with proper library or fallback
            function evaluateFunction(func, x) {
                if (typeof func === 'function') {
                    // Fallback function
                    return func(x);
                } else if (mathAvailable && func.evaluate) {
                    // Math.js function
                    return func.evaluate({x: x});
                } else {
                    throw new Error('Cannot evaluate function');
                }
            }
            
            // Simple average function
            function average(arr) {
                return arr.reduce((a, b) => a + b, 0) / arr.length;
            }
            
            // Plot function graph
            function plotFunction(func, point, dir, limitValue) {
                if (plotlyAvailable) {
                    plotWithPlotly(func, point, dir, limitValue);
                } else {
                    plotWithCanvas(func, point, dir, limitValue);
                }
            }
            
            // Plot with Plotly
            function plotWithPlotly(func, point, dir, limitValue) {
                try {
                    // Determine x range
                    let xMin, xMax;
                    
                    if (point === Infinity) {
                        xMin = 0.1;
                        xMax = 10;
                    } else if (point === -Infinity) {
                        xMin = -10;
                        xMax = -0.1;
                    } else {
                        const range = Math.max(3, Math.abs(point) * 1.5);
                        xMin = point - range;
                        xMax = point + range;
                    }
                    
                    // Generate x values
                    const step = (xMax - xMin) / 200;
                    const xValues = [];
                    const yValues = [];
                    
                    for (let x = xMin; x <= xMax; x += step) {
                        // Skip exactly at the limit point
                        if (Math.abs(x - point) < step / 2 && isFinite(point)) {
                            continue;
                        }
                        
                        try {
                            const y = evaluateFunction(func, x);
                            if (isFinite(y)) {
                                xValues.push(x);
                                yValues.push(y);
                            } else {
                                // Break the line
                                xValues.push(NaN);
                                yValues.push(NaN);
                            }
                        } catch (e) {
                            xValues.push(NaN);
                            yValues.push(NaN);
                        }
                    }
                    
                    // Create traces
                    const traces = [{
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines',
                        line: {color: '#303f9f', width: 2},
                        name: 'f(x)'
                    }];
                    
                    // Add limit point if finite
                    if (isFinite(point)) {
                        traces.push({
                            x: [point, point],
                            y: [Math.min(...yValues.filter(y => isFinite(y))), 
                                Math.max(...yValues.filter(y => isFinite(y)))],
                            type: 'scatter',
                            mode: 'lines',
                            line: {color: 'rgba(244, 67, 54, 0.7)', width: 1, dash: 'dash'},
                            name: `x = ${point}`
                        });
                    }
                    
                    // Update graph
                    Plotly.react(graph, traces, {
                        title: `Graph of f(x) = ${functionInput.value.substring(0, 30)}${functionInput.value.length > 30 ? '...' : ''}`,
                        xaxis: {title: 'x'},
                        yaxis: {title: 'f(x)', autorange: true},
                        plot_bgcolor: '#f8f9fa',
                        paper_bgcolor: '#ffffff'
                    });
                    
                } catch (e) {
                    console.error('Plotly plotting error:', e);
                    plotWithCanvas(func, point, dir, limitValue);
                }
            }
            
            // Plot with Canvas fallback
            function plotWithCanvas(func, point, dir, limitValue) {
                const canvas = graphFallback;
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                const padding = 40;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                // Determine x range
                let xMin, xMax;
                if (isFinite(point)) {
                    xMin = point - 5;
                    xMax = point + 5;
                } else {
                    xMin = -5;
                    xMax = 5;
                }
                
                // Draw axes
                ctx.strokeStyle = '#999';
                ctx.lineWidth = 1;
                
                // X axis
                const yZero = height - padding;
                ctx.beginPath();
                ctx.moveTo(padding, yZero);
                ctx.lineTo(width - padding, yZero);
                ctx.stroke();
                
                // Y axis
                const xZero = padding;
                ctx.beginPath();
                ctx.moveTo(xZero, padding);
                ctx.lineTo(xZero, height - padding);
                ctx.stroke();
                
                // Plot function
                ctx.strokeStyle = '#303f9f';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                let firstPoint = true;
                const plotWidth = width - 2 * padding;
                const plotHeight = height - 2 * padding;
                
                for (let i = 0; i <= plotWidth; i++) {
                    const x = xMin + (i / plotWidth) * (xMax - xMin);
                    
                    try {
                        const y = evaluateFunction(func, x);
                        
                        if (isFinite(y)) {
                            // Scale to canvas coordinates
                            const canvasX = padding + i;
                            const canvasY = yZero - (y * plotHeight) / (2 * Math.max(Math.abs(y), 5));
                            
                            if (firstPoint) {
                                ctx.moveTo(canvasX, canvasY);
                                firstPoint = false;
                            } else {
                                ctx.lineTo(canvasX, canvasY);
                            }
                        } else {
                            firstPoint = true;
                        }
                    } catch (e) {
                        firstPoint = true;
                    }
                }
                
                ctx.stroke();
                
                // Draw limit point
                if (isFinite(point)) {
                    ctx.strokeStyle = '#f44336';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    const pointX = padding + ((point - xMin) / (xMax - xMin)) * plotWidth;
                    ctx.moveTo(pointX, padding);
                    ctx.lineTo(pointX, height - padding);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Add labels
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('x', width - padding + 10, yZero + 15);
                ctx.textAlign = 'right';
                ctx.fillText('f(x)', padding - 10, padding - 5);
                
                // Add title
                ctx.textAlign = 'center';
                ctx.font = '14px Arial';
                ctx.fillText(`f(x) = ${functionInput.value.substring(0, 25)}${functionInput.value.length > 25 ? '...' : ''}`, 
                           width / 2, 20);
            }
            
            // Reset form
            function resetForm() {
                functionInput.value = 'sin(x)/x';
                limitPoint.value = '0';
                direction.value = 'both';
                result.innerHTML = 'Click "Calculate Limit" to see result';
                initializeGraph();
            }
            
            // Load example
            function loadExample(func, point) {
                functionInput.value = func;
                limitPoint.value = point;
                calculateLimit();
            }
            
            // Event listeners
            calculateBtn.addEventListener('click', calculateLimit);
            resetBtn.addEventListener('click', resetForm);
            
            exampleItems.forEach(item => {
                item.addEventListener('click', () => {
                    const func = item.getAttribute('data-func');
                    const point = item.getAttribute('data-point');
                    loadExample(func, point);
                });
            });
            
            // Calculate on Enter
            functionInput.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') calculateLimit();
            });
            
            limitPoint.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') calculateLimit();
            });
            
            // Initialize
            initializeGraph();
            
            // Calculate initial example after a short delay
            setTimeout(() => {
                calculateLimit();
            }, 500);
            
            console.log('Calculator initialized successfully');
        });
    </script>
</body>
</html>

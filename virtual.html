<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Function Limit Calculator with Graph</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a237e 0%, #4a148c 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(90deg, #303f9f 0%, #512da8 100%);
            color: white;
            padding: 25px;
            text-align: center;
        }
        
        h1 {
            font-size: 2rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1rem;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .content {
            display: flex;
            flex-wrap: wrap;
            padding: 20px;
            gap: 20px;
        }
        
        .input-section {
            flex: 1;
            min-width: 300px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }
        
        .graph-section {
            flex: 2;
            min-width: 300px;
            padding: 20px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            border: 1px solid #e0e0e0;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #303f9f;
        }
        
        input, select {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #c5cae9;
            border-radius: 6px;
            font-size: 1rem;
            transition: border-color 0.3s;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: #303f9f;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        #calculateBtn {
            background-color: #303f9f;
            color: white;
        }
        
        #calculateBtn:hover {
            background-color: #283593;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(48, 63, 159, 0.3);
        }
        
        #resetBtn {
            background-color: #f5f5f5;
            color: #555;
        }
        
        #resetBtn:hover {
            background-color: #e0e0e0;
            transform: translateY(-2px);
        }
        
        .result-box {
            margin-top: 20px;
            padding: 15px;
            background-color: #e8eaf6;
            border-radius: 6px;
            border-left: 5px solid #303f9f;
        }
        
        .result-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #303f9f;
        }
        
        #result {
            font-size: 1.1rem;
            font-family: 'Courier New', monospace;
            min-height: 24px;
        }
        
        .graph-container {
            width: 100%;
            height: 400px;
            background-color: white;
            border-radius: 6px;
            margin-top: 10px;
            position: relative;
            border: 1px solid #ddd;
        }
        
        #graphCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .graph-controls {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 0.9rem;
            color: #666;
        }
        
        .instructions {
            margin-top: 20px;
            padding: 15px;
            background-color: #f1f8e9;
            border-radius: 8px;
            border-left: 5px solid #7cb342;
        }
        
        .instructions h3 {
            color: #558b2f;
            margin-bottom: 8px;
            font-size: 1.1rem;
        }
        
        .instructions ul {
            padding-left: 20px;
            font-size: 0.9rem;
        }
        
        .instructions li {
            margin-bottom: 6px;
        }
        
        .example-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 8px;
            margin-top: 12px;
        }
        
        .example-item {
            padding: 8px;
            background-color: white;
            border-radius: 5px;
            border: 1px solid #c5cae9;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85rem;
        }
        
        .example-item:hover {
            background-color: #e8eaf6;
            transform: translateY(-2px);
        }
        
        .function-example {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #303f9f;
            margin-bottom: 4px;
        }
        
        footer {
            text-align: center;
            padding: 15px;
            color: #9e9e9e;
            font-size: 0.8rem;
            border-top: 1px solid #eee;
        }
        
        .error-message {
            color: #d32f2f;
            background-color: #ffebee;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            display: none;
        }
        
        .info-box {
            background-color: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .content {
                flex-direction: column;
            }
            
            h1 {
                font-size: 1.5rem;
            }
            
            .graph-container {
                height: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Function Limit Calculator</h1>
            <p class="subtitle">Enter a mathematical function, specify the limit point, and visualize the function graph</p>
        </header>
        
        <div class="info-box">
            <strong>Note:</strong> This calculator uses HTML5 Canvas for graphing - no external libraries required!
        </div>
        
        <div class="content">
            <div class="input-section">
                <div class="input-group">
                    <label for="functionInput">Function f(x)</label>
                    <input type="text" id="functionInput" value="sin(x)/x" placeholder="e.g., sin(x)/x, x^2+2*x+1">
                    <small>Use: sin(x), cos(x), tan(x), log(x), sqrt(x), ^ for power, * for multiplication</small>
                </div>
                
                <div class="input-group">
                    <label for="limitPoint">Limit Point (x → a)</label>
                    <input type="text" id="limitPoint" value="0" placeholder="Enter a number or 'inf' for infinity">
                </div>
                
                <div class="input-group">
                    <label for="direction">Direction</label>
                    <select id="direction">
                        <option value="both">Both sides (x → a)</option>
                        <option value="left">Left side only (x → a⁻)</option>
                        <option value="right">Right side only (x → a⁺)</option>
                    </select>
                </div>
                
                <div class="input-group">
                    <label>Try these examples:</label>
                    <div class="example-list">
                        <div class="example-item" data-func="sin(x)/x" data-point="0">
                            <div class="function-example">sin(x)/x</div>
                            <div>as x → 0</div>
                        </div>
                        <div class="example-item" data-func="(x^2-1)/(x-1)" data-point="1">
                            <div class="function-example">(x²-1)/(x-1)</div>
                            <div>as x → 1</div>
                        </div>
                        <div class="example-item" data-func="1/x" data-point="0">
                            <div class="function-example">1/x</div>
                            <div>as x → 0</div>
                        </div>
                        <div class="example-item" data-func="x*sin(1/x)" data-point="0">
                            <div class="function-example">x*sin(1/x)</div>
                            <div>as x → 0</div>
                        </div>
                    </div>
                </div>
                
                <div class="button-group">
                    <button id="calculateBtn">Calculate Limit</button>
                    <button id="resetBtn">Reset</button>
                </div>
                
                <div class="result-box">
                    <div class="result-title">Limit Result:</div>
                    <div id="result">Click "Calculate Limit" to see result</div>
                </div>
            </div>
            
            <div class="graph-section">
                <h2>Graphical Representation</h2>
                <div class="graph-controls">
                    <span id="graphInfo">Function: f(x) = sin(x)/x</span>
                    <span id="coordInfo">Move mouse over graph to see coordinates</span>
                </div>
                <div class="graph-container">
                    <canvas id="graphCanvas"></canvas>
                </div>
            </div>
        </div>
        
        <div class="instructions">
            <h3>How to Use This Calculator</h3>
            <ul>
                <li>Enter a mathematical function using standard notation</li>
                <li>Specify the limit point (number or "inf" for infinity)</li>
                <li>Select the direction of approach</li>
                <li>Click "Calculate Limit" to compute and visualize</li>
                <li>Click on any example to try it</li>
                <li>Hover over the graph to see coordinates</li>
            </ul>
        </div>
        
        <footer>
            <p>Function Limit Calculator with Graph | Pure HTML5/JavaScript Implementation</p>
        </footer>
    </div>

    <script>
        // Main Calculator Class
        class LimitCalculator {
            constructor() {
                this.canvas = document.getElementById('graphCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.functionInput = document.getElementById('functionInput');
                this.limitPoint = document.getElementById('limitPoint');
                this.direction = document.getElementById('direction');
                this.result = document.getElementById('result');
                this.graphInfo = document.getElementById('graphInfo');
                this.coordInfo = document.getElementById('coordInfo');
                
                this.setupCanvas();
                this.bindEvents();
                this.initialize();
            }
            
            setupCanvas() {
                // Set canvas dimensions
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    this.canvas.width = container.clientWidth;
                    this.canvas.height = container.clientHeight;
                    this.plotFunction(this.currentFunc, this.currentPoint, this.currentDir, this.currentLimit);
                });
                
                // Mouse move for coordinates
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    if (this.currentGraphBounds) {
                        const graphX = this.pixelToGraphX(x);
                        const graphY = this.pixelToGraphY(y);
                        this.coordInfo.textContent = `x = ${graphX.toFixed(3)}, y = ${graphY.toFixed(3)}`;
                    }
                });
            }
            
            bindEvents() {
                document.getElementById('calculateBtn').addEventListener('click', () => this.calculateLimit());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
                
                // Example click events
                document.querySelectorAll('.example-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const func = item.getAttribute('data-func');
                        const point = item.getAttribute('data-point');
                        this.functionInput.value = func;
                        this.limitPoint.value = point;
                        this.calculateLimit();
                    });
                });
                
                // Enter key support
                this.functionInput.addEventListener('keyup', (e) => {
                    if (e.key === 'Enter') this.calculateLimit();
                });
                
                this.limitPoint.addEventListener('keyup', (e) => {
                    if (e.key === 'Enter') this.calculateLimit();
                });
            }
            
            initialize() {
                this.calculateLimit();
            }
            
            calculateLimit() {
                const funcStr = this.functionInput.value.trim();
                const pointStr = this.limitPoint.value.trim();
                const dir = this.direction.value;
                
                if (!funcStr || !pointStr) {
                    this.result.innerHTML = '<span style="color:red">Please enter function and limit point</span>';
                    return;
                }
                
                this.result.textContent = 'Calculating...';
                
                try {
                    // Parse function
                    const func = this.parseFunction(funcStr);
                    
                    // Parse limit point
                    let point;
                    if (pointStr.toLowerCase() === 'inf' || pointStr === '∞') {
                        point = Infinity;
                    } else if (pointStr.toLowerCase() === '-inf' || pointStr === '-∞') {
                        point = -Infinity;
                    } else {
                        point = parseFloat(pointStr);
                        if (isNaN(point)) {
                            throw new Error('Invalid limit point');
                        }
                    }
                    
                    // Calculate limit
                    let limitValue;
                    if (point === Infinity || point === -Infinity) {
                        limitValue = this.calculateLimitAtInfinity(func, point);
                    } else {
                        limitValue = this.calculateLimitAtPoint(func, point, dir);
                    }
                    
                    // Display result
                    this.displayResult(limitValue, point, dir);
                    
                    // Store current values
                    this.currentFunc = func;
                    this.currentPoint = point;
                    this.currentDir = dir;
                    this.currentLimit = limitValue;
                    
                    // Plot function
                    this.plotFunction(func, point, dir, limitValue);
                    
                } catch (error) {
                    this.result.innerHTML = `<span style="color:red">Error: ${error.message}</span>`;
                    console.error(error);
                }
            }
            
            parseFunction(funcStr) {
                // Replace ^ with ** for exponentiation
                funcStr = funcStr.replace(/\^/g, '**');
                
                return (x) => {
                    try {
                        // Handle special cases
                        if (x === 0 && funcStr.includes('/x')) {
                            // Avoid division by zero
                            return this.evaluateFunction(funcStr, x + 1e-10);
                        }
                        
                        return this.evaluateFunction(funcStr, x);
                    } catch (e) {
                        throw new Error(`Cannot evaluate function at x = ${x}`);
                    }
                };
            }
            
            evaluateFunction(funcStr, x) {
                // Create a safe evaluation
                const safeFuncStr = funcStr
                    .replace(/sin\(/g, 'Math.sin(')
                    .replace(/cos\(/g, 'Math.cos(')
                    .replace(/tan\(/g, 'Math.tan(')
                    .replace(/log\(/g, 'Math.log(')
                    .replace(/sqrt\(/g, 'Math.sqrt(')
                    .replace(/exp\(/g, 'Math.exp(')
                    .replace(/abs\(/g, 'Math.abs(')
                    .replace(/pi/g, 'Math.PI')
                    .replace(/e/g, 'Math.E');
                
                // Replace x with its value
                const expr = safeFuncStr.replace(/x/g, `(${x})`);
                
                try {
                    return eval(expr);
                } catch (e) {
                    return NaN;
                }
            }
            
            calculateLimitAtPoint(func, point, dir) {
                const epsilons = [0.1, 0.01, 0.001, 0.0001, 0.00001];
                let leftValues = [];
                let rightValues = [];
                
                for (let eps of epsilons) {
                    if (dir === 'both' || dir === 'left') {
                        const x = point - eps;
                        const y = func(x);
                        if (!isNaN(y) && isFinite(y)) leftValues.push(y);
                    }
                    
                    if (dir === 'both' || dir === 'right') {
                        const x = point + eps;
                        const y = func(x);
                        if (!isNaN(y) && isFinite(y)) rightValues.push(y);
                    }
                }
                
                if (dir === 'both') {
                    if (leftValues.length === 0 || rightValues.length === 0) return undefined;
                    
                    const leftAvg = this.average(leftValues);
                    const rightAvg = this.average(rightValues);
                    
                    if (Math.abs(leftAvg - rightAvg) > 0.001) return undefined;
                    return (leftAvg + rightAvg) / 2;
                    
                } else if (dir === 'left') {
                    if (leftValues.length === 0) return undefined;
                    return this.average(leftValues);
                    
                } else {
                    if (rightValues.length === 0) return undefined;
                    return this.average(rightValues);
                }
            }
            
            calculateLimitAtInfinity(func, infinityDir) {
                const largeNumbers = infinityDir === Infinity ? 
                    [10, 50, 100, 500, 1000] : 
                    [-10, -50, -100, -500, -1000];
                
                const values = [];
                for (let x of largeNumbers) {
                    const y = func(x);
                    if (!isNaN(y) && isFinite(y)) values.push(y);
                }
                
                if (values.length === 0) return undefined;
                
                // Check for divergence
                const lastValue = values[values.length - 1];
                if (values.length >= 3) {
                    const secondLast = values[values.length - 2];
                    if (Math.abs(lastValue) > Math.abs(secondLast) * 10) {
                        return lastValue > 0 ? Infinity : -Infinity;
                    }
                }
                
                return this.average(values);
            }
            
            average(arr) {
                return arr.reduce((a, b) => a + b, 0) / arr.length;
            }
            
            displayResult(limitValue, point, dir) {
                let pointDisplay = point === Infinity ? '∞' : point === -Infinity ? '-∞' : point;
                let dirSymbol = dir === 'left' ? '⁻' : dir === 'right' ? '⁺' : '';
                
                if (limitValue === undefined) {
                    this.result.innerHTML = `Limit does not exist as x → ${pointDisplay}${dirSymbol}`;
                } else if (limitValue === Infinity) {
                    this.result.innerHTML = `lim<sub>x→${pointDisplay}${dirSymbol}</sub> f(x) = ∞`;
                } else if (limitValue === -Infinity) {
                    this.result.innerHTML = `lim<sub>x→${pointDisplay}${dirSymbol}</sub> f(x) = -∞`;
                } else {
                    this.result.innerHTML = `lim<sub>x→${pointDisplay}${dirSymbol}</sub> f(x) = ${limitValue.toFixed(6)}`;
                }
            }
            
            plotFunction(func, point, dir, limitValue) {
                // Update graph info
                this.graphInfo.textContent = `Function: f(x) = ${this.functionInput.value}`;
                
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Determine graph bounds
                let xMin, xMax;
                if (point === Infinity) {
                    xMin = 0.1;
                    xMax = 10;
                } else if (point === -Infinity) {
                    xMin = -10;
                    xMax = -0.1;
                } else if (isFinite(point)) {
                    const range = Math.max(4, Math.abs(point) * 1.5);
                    xMin = point - range;
                    xMax = point + range;
                } else {
                    xMin = -5;
                    xMax = 5;
                }
                
                // Sample function values
                const samples = 500;
                const step = (xMax - xMin) / samples;
                const points = [];
                
                for (let i = 0; i <= samples; i++) {
                    const x = xMin + i * step;
                    const y = func(x);
                    
                    if (!isNaN(y) && isFinite(y)) {
                        points.push({x, y});
                    } else {
                        points.push(null); // Break in the graph
                    }
                }
                
                // Find y range
                const validPoints = points.filter(p => p !== null);
                if (validPoints.length === 0) return;
                
                let yMin = validPoints[0].y;
                let yMax = validPoints[0].y;
                validPoints.forEach(p => {
                    if (p.y < yMin) yMin = p.y;
                    if (p.y > yMax) yMax = p.y;
                });
                
                // Add some padding
                const yRange = yMax - yMin;
                yMin -= yRange * 0.1;
                yMax += yRange * 0.1;
                
                if (yRange === 0) {
                    yMin -= 1;
                    yMax += 1;
                }
                
                // Store graph bounds for coordinate conversion
                this.currentGraphBounds = { xMin, xMax, yMin, yMax };
                
                // Draw coordinate system
                this.drawCoordinateSystem(xMin, xMax, yMin, yMax);
                
                // Draw function
                this.drawFunction(points, xMin, xMax, yMin, yMax);
                
                // Draw limit point
                if (isFinite(point)) {
                    this.drawLimitPoint(point, limitValue, xMin, xMax, yMin, yMax);
                }
            }
            
            drawCoordinateSystem(xMin, xMax, yMin, yMax) {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const padding = 40;
                
                // Draw background
                this.ctx.fillStyle = '#f8f9fa';
                this.ctx.fillRect(0, 0, width, height);
                
                // Calculate scaling factors
                const graphWidth = width - 2 * padding;
                const graphHeight = height - 2 * padding;
                
                // Draw grid
                this.ctx.strokeStyle = '#e0e0e0';
                this.ctx.lineWidth = 1;
                
                // Vertical grid lines
                const xStep = this.getGridStep(xMax - xMin);
                for (let x = Math.ceil(xMin / xStep) * xStep; x <= xMax; x += xStep) {
                    const pixelX = padding + ((x - xMin) / (xMax - xMin)) * graphWidth;
                    this.ctx.beginPath();
                    this.ctx.moveTo(pixelX, padding);
                    this.ctx.lineTo(pixelX, height - padding);
                    this.ctx.stroke();
                    
                    // Draw x-axis label
                    if (Math.abs(x) > 0.01) {
                        this.ctx.fillStyle = '#666';
                        this.ctx.font = '10px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(x.toFixed(1), pixelX, height - padding + 15);
                    }
                }
                
                // Horizontal grid lines
                const yStep = this.getGridStep(yMax - yMin);
                for (let y = Math.ceil(yMin / yStep) * yStep; y <= yMax; y += yStep) {
                    const pixelY = height - padding - ((y - yMin) / (yMax - yMin)) * graphHeight;
                    this.ctx.beginPath();
                    this.ctx.moveTo(padding, pixelY);
                    this.ctx.lineTo(width - padding, pixelY);
                    this.ctx.stroke();
                    
                    // Draw y-axis label
                    if (Math.abs(y) > 0.01) {
                        this.ctx.fillStyle = '#666';
                        this.ctx.font = '10px Arial';
                        this.ctx.textAlign = 'right';
                        this.ctx.fillText(y.toFixed(1), padding - 5, pixelY + 3);
                    }
                }
                
                // Draw axes
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 2;
                
                // X-axis
                const yZeroPixel = height - padding + (yMin / (yMax - yMin)) * graphHeight;
                this.ctx.beginPath();
                this.ctx.moveTo(padding, yZeroPixel);
                this.ctx.lineTo(width - padding, yZeroPixel);
                this.ctx.stroke();
                
                // Y-axis
                const xZeroPixel = padding - (xMin / (xMax - xMin)) * graphWidth;
                this.ctx.beginPath();
                this.ctx.moveTo(xZeroPixel, padding);
                this.ctx.lineTo(xZeroPixel, height - padding);
                this.ctx.stroke();
                
                // Draw axis labels
                this.ctx.fillStyle = '#333';
                this.ctx.font = '12px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('x', width - padding + 20, yZeroPixel + 15);
                this.ctx.textAlign = 'right';
                this.ctx.fillText('f(x)', xZeroPixel - 10, padding - 10);
            }
            
            getGridStep(range) {
                const steps = [0.1, 0.2, 0.5, 1, 2, 5, 10, 20, 50, 100];
                const target = range / 10;
                for (let step of steps) {
                    if (step >= target) return step;
                }
                return steps[steps.length - 1];
            }
            
            drawFunction(points, xMin, xMax, yMin, yMax) {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const padding = 40;
                const graphWidth = width - 2 * padding;
                const graphHeight = height - 2 * padding;
                
                this.ctx.strokeStyle = '#303f9f';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                
                let firstPoint = true;
                
                for (let i = 0; i < points.length; i++) {
                    const point = points[i];
                    
                    if (point === null) {
                        firstPoint = true;
                        continue;
                    }
                    
                    const pixelX = padding + ((point.x - xMin) / (xMax - xMin)) * graphWidth;
                    const pixelY = height - padding - ((point.y - yMin) / (yMax - yMin)) * graphHeight;
                    
                    if (firstPoint) {
                        this.ctx.moveTo(pixelX, pixelY);
                        firstPoint = false;
                    } else {
                        this.ctx.lineTo(pixelX, pixelY);
                    }
                }
                
                this.ctx.stroke();
            }
            
            drawLimitPoint(point, limitValue, xMin, xMax, yMin, yMax) {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const padding = 40;
                const graphWidth = width - 2 * padding;
                const graphHeight = height - 2 * padding;
                
                // Draw vertical line at limit point
                const pixelX = padding + ((point - xMin) / (xMax - xMin)) * graphWidth;
                
                this.ctx.strokeStyle = 'rgba(244, 67, 54, 0.7)';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(pixelX, padding);
                this.ctx.lineTo(pixelX, height - padding);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                
                // Draw limit point if limit exists
                if (limitValue !== undefined && isFinite(limitValue)) {
                    const pixelY = height - padding - ((limitValue - yMin) / (yMax - yMin)) * graphHeight;
                    
                    // Draw point
                    this.ctx.fillStyle = '#f44336';
                    this.ctx.beginPath();
                    this.ctx.arc(pixelX, pixelY, 6, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Draw label
                    this.ctx.fillStyle = '#d32f2f';
                    this.ctx.font = 'bold 12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(`Limit: ${limitValue.toFixed(3)}`, pixelX, pixelY - 10);
                }
            }
            
            pixelToGraphX(pixelX) {
                if (!this.currentGraphBounds) return 0;
                const { xMin, xMax } = this.currentGraphBounds;
                const padding = 40;
                const graphWidth = this.canvas.width - 2 * padding;
                return xMin + ((pixelX - padding) / graphWidth) * (xMax - xMin);
            }
            
            pixelToGraphY(pixelY) {
                if (!this.currentGraphBounds) return 0;
                const { yMin, yMax } = this.currentGraphBounds;
                const padding = 40;
                const graphHeight = this.canvas.height - 2 * padding;
                return yMax - ((pixelY - padding) / graphHeight) * (yMax - yMin);
            }
            
            reset() {
                this.functionInput.value = 'sin(x)/x';
                this.limitPoint.value = '0';
                this.direction.value = 'both';
                this.result.textContent = 'Click "Calculate Limit" to see result';
                this.calculateLimit();
            }
        }
        
        // Initialize calculator when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new LimitCalculator();
        });
    </script>
</body>
</html>
